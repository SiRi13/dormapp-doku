\section{Weboberfäche}\label{section:WebUI}
Der Administrator einer WG muss in der Lage sein, die Eigenschaften der WG zu konfigurieren und die Funktionen zu verwalten. Wir haben uns dazu entschieden, eine extern jederzeit erreichbare Weboberfläche dafür bereit zu stellen. Wir hätten uns genauso gut für die Implementierung in die Android App entscheiden können, haben uns jedoch bewusst dagegen entschieden. Wir möchten mit den unterschiedlichen Programmiersprachen und den daraus resultierenden Herangehensweisen eine möglichst großes Vielfalt der Informatik widerspiegeln und die Arbeiten auf die Mitglieder verteilen, die bisher noch keine Erfahrung mit der Programmierung für die Android Plattform sammeln konnten.\\
Im folgenden Kapitel wird die Weboberfläche mit Hilfe von Codesnippets erläutert.

\subsection{Umsetzung}\label{subSec:WebUmsetz}
Als Programmiersprache haben wir uns für die sehr beliebte und weit verbreitete Skriptsprache PHP entschieden. PHP bietet durch den Einfluss von Java, C++ und Perl einen leichten Einstieg für diejenigen, die bereits erste Erfahrungen mit einer der Programmiersprachen sammeln konnten. Ausserdem bietet PHP die einfache Umsetzung von dynamischen Webseiten und eine sehr gute Unterstützung von Datenbankverbindungen. Mit PHP ist automatisch sichergestellt, dass die Weboberfläche von jedem gängigen Browser aus in deren Desktop- sowie Mobilversion genutzt werden kann.\\
\begin{description}
\item Die Weboberfläche gliedert sich in neun Seiten:
\dirtree{%
.0 /.
.2 admin.php.
.2 benutzer.php.
.2 blackboard.php.
.2 einkaufsliste.php.
.2 login.php.
.2 logout.php.
.2 putzplan.php.
.2 regist.php.
.2 system.php.
}
\end{description}
Jede dieser PHP Dateien stellt eine Seite der Weboberfläche dar. Jede Datei beinhaltet gewöhnlichen HTML Code für die Anzeige im Browser und PHP Code für den dynamischen Teil der Datenabfrage von der Datenbank.\\
Mehrzeilige Abfragen in PHP sind in eigene Dateien ausgelagert. So ist z.B. die Abfrage zum löschen eines WG Mitglieds in der Datei  \textit{benutzer\textunderscore edit\textunderscore delete.php} zu finden. So verfahren wir mit allen mehrzeiligen Abfragen um die Übersichtlichkeit zu erhöhen.\\
\begin{figure}
\begin{description}
\item Daraus ergibt sich folgende Struktur für die Weboberfläche mit ihren Seiten inklusive aller ausgelagerten PHP Abfragen:
\dirtree{%
.1 /.
.2 admin.php.
.2 benutzer.php.
.3 benutzer\textunderscore aktivierung.php.
.3 benutzer\textunderscore edit\textunderscore delete.php.
.3 benutzer\textunderscore script.php.
.3 benutzer\textunderscore update.php.
.2 blackboard.php.
.3 blackboard\textunderscore add.php.
.3 blackboard\textunderscore delete\textunderscore edit.php.
.3 blackboard\textunderscore update.php.
.2 einkaufsliste.
.3 einkaufsliste\textunderscore add.php.
.3 einkaufsliste\textunderscore delete\textunderscore edit.php.
.3 waren\textunderscore add\textunderscore delete.php.
.3 waren\textunderscore add.php.
.2 login.
.3 login\textunderscore script.php.
.2 logout.php.
.2 putzplan.php.
.3 putzplan\textunderscore add.php.
.3 putzplan\textunderscore delete\textunderscore edit.php.
.3 putzplan\textunderscore unteraufgaben\textunderscore add.php.
.3 putzplan\textunderscore unteraufgaben\textunderscore update.php.
.3 putzplan\textunderscore update.php.
.2 regist.php.
.3 regist\textunderscore script.php.
.2 system.php.
.3 system\textunderscore delete\textunderscore edit.php.
.3 system\textunderscore update.php.
.2 style.css.
}
\end{description}
\end{figure}
Alle Eingaben die der Benutzer in der Weboberfläche machen kann, werden durch Textfeder oder Checkboxen erfasst. Wir verwenden für alle zu übertragenden Daten die Methode POST, die die Daten für Benutzer der Seiten unsichtbar im Rumpf des HTTP-Requests sendet. Die Methode GET, die die Daten für alle sichtbar an die URI anhängt, könnte theoretisch ebenfalls genutzt werden. Jedoch würde das in unserem Fall ein erhöhtes Sicherheitsrisiko darstellen. Darum haben wir bis auf wenige ID's auf die Methode GET verzichtet.\\ \\
\begin{figure}
Auf jeder HTML Seite und in jedem PHP Skript wird zu Beginn überprüft, ob der Nutzer im System angemeldet ist. Falls die Prüfung fehlschlägt, wird ihm mit dem Hinweis \textit{Bitte loggen Sie sich erst ein!} die Anzeige der Seite verwehrt und das PHP Script wird mit \textit{exit;} gestoppt.

\begin{lstlisting}[language=PHP, caption=Login des Benutzers überprüfen, captionpos=below, label=WEBLogin]
if(!isset($_SESSION["email"]))
{
	echo("<a href=\"login.php\" />Bitte loggen sie sich erst ein!</a>");
	exit;
}
\end{lstlisting}
\end{figure}

Ist der Benutzer eingeloggt, wird das PHP Script nicht gestoppt, sondern weiter verarbeitet. Mit einem \textit{require_oce 'db_inc.php} wird die Datei db_inc.php eingebunden und ausgeführt. Das passiert aber nur, wenn die Datei nicht schon vorher durch ein anderes Script eingebunden wurde.

\begin{lstlisting}[language=PHP, caption=Login des Benutzers überprüfen, captionpos=below, label=WEBLogin]
require_once 'db_inc.php';	
\end{lstlisting}
\end{figure}

Im Anschluss können die über die POST bzw. GET von der HTML Seite übergebenen Parameter abgefragt und zwischengespeichert werden. In dem Beispiel wird mit einer if-Anfrage geprüft, ob ein Parameter "einkaufsliste_id" geliefert wurde, falls dies der Fall ist, wird der Inhalt der Variablen lokal zwischengespeichert.

\begin{lstlisting}[language=PHP, caption=Login des Benutzers überprüfen, captionpos=below, label=WEBLogin]
if(isset($_POST['einkaufsliste_id']))
{
	$einkaufsliste_id = $_POST['einkaufsliste_id'];
}
\end{lstlisting}
\end{figure}
 