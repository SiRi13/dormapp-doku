\section{App}\label{section:App}
Dieses Kapitel umfasst die Implementierung der App, auf der die weiteren Teile aufbauen. Dabei wird näher auf die
service-ähnliche Struktur und deren Umsetzung, sowie die sichere Speicherung von Benutzerinformationen eingegangen. 
Anfangs wird der Ablauf beim ersten Start, den folgenden Starts sowohl mit als auch ohne angemeldetem
Benutzer beschrieben.
\\*
Da eine Verwendung der App ohne Anmeldung, sprich ohne personalisierte Daten, nicht vorgesehen ist, wird zunächst der
App-Speicher auf vorhandene Login-Informationen überprüft. Aufgrund der Annahme, dass es sich um die erste Verwendung
nach der Installation handelt, können noch keine Benutzerdaten vorhanden sein und es wird direkt in die
\textsl{LoginActivity} weitergeleitet, die ohne Anmeldung nicht verlassen werden kann. Hat sich der Benutzer erfolgreich
authentifiziert, startet die Synchronisierung aller Tabellen, um die aktuellsten Daten zu erhalten. Ein Beenden ohne
Logout hat zur Folge, dass E-Mailadresse und Passwort über die \texttt{Secure-Preferences}-Schnittstelle verschlüsselt
im Speicherbereich abgelegt werden. Dies erfolgt in der \textsl{onPause()}-Methode, um den Verlust der Daten beim
Zerstören der App aufgrund von Ressourcenknappheit zu verhindern. Beim darauffolgenden Start wird in der
\textsl{onResume()}-Methode geprüft, ob verschlüsselte Credentials im Speicher hinterlegt sind. Nach dem Auslesen werden
damit die aktuellen Bewegungsdaten aus der Datenbank abgerufen und lokal gespeichert. Hat sich der Benutzer vor
dem Beenden der App abgemeldet, wurden beim Schließen keine Informationen im App-Speicher abgelegt. Dadurch landet der
Benutzer, wie beim Erststart, wieder in der Loginmaske.

\subsection{Probleme}\label{subsec:AppProbl}
Neben denen in Kapitel \ref{chp:Prototyp} - \nameref{chp:Prototyp} gelösten Problemen, die schon vor dem Beginn der Implementierung erkannt 
wurden, sind auch während der Umsetzung einige Stolperfallen aufgetreten. Dazu gehört zunächst die Herausforderung, die
Logininformationen so sicher wie möglich zu speichern. Des Weiteren sollte die Server- und Datenbankkommunikation
möglichst unabhängig vom Darstellungsteil der App gehalten werden.

\paragraph*{Unsichere App-Speicher}\label{para:unsafeStorage}
Da der \verb!SharedPreference!-Speicher nicht verschlüsselt ist und durch einfache Mittel ausgelesen werden kann, dürfen
dort keine sensiblen Daten ohne weiteres gespeichert werden. Die sicherste Art wäre es, die Logininformationen nicht zu
speichern, was aber dazu führen würde, dass sich der Benutzer bei jedem Start der App neu anmelden müsste. Das ist dem
Benutzer aber unter keinerlei Umständen zumutbar.

\paragraph*{Datenbank-Service}\label{para:dbService}
Das Trennen der Oberfläche von der Datenhaltung hat mehrere Vorteile und wurde deswegen in diesem Projekt
umgesetzt. Zunächst ist es dadurch möglich die Kommunikation zwischen App und Datenbank zu ändern, ohne dass die
Oberfläche angepasst werden muss. Weiterhin ist es dadurch einfacher die Umsetzung auf verschiedene Entwickler
aufzuteilen, da keine ständige Rücksprache nötig ist, sondern nur zu Beginn die Schnittstelle bereits definiert sein muss.

\subsection{Lösungen}\label{subsec:AppSol}
Zur Lösung der vorangegangenen Probleme, sind nachfolgend kurze Auszüge aus dem Quelltext mit einer knappen 
Erläuterung der Funktion.

\paragraph*{Secure-Preferences}\label{para:secPrefs}
Wie zuvor erwähnt, ist der App-Speicher nicht verschlüsselt und somit eigentlich für die Ablage von Passwörtern
ungeeignet. Die Lösung dieses Problems bringt der Einsatz einer Verschlüsselung beim Schreiben der \verb!SharedPreferences!.
Dabei kommt die schon erwähnte Bibliothek \emph{Secure-Preferences} ins Spiel, wodurch die Informationen vor dem
Schreiben in den App-Speicher verschlüsselt werden. Dabei wird einfach die schon vorhandene \verb!SharedPreferences!-Funktion
von Android mit einer extra Schnittstelle dazwischen verwendet, die beim Schreiben ver- und beim Lesen entschlüsselt.
Die Verwendung der \emph{Secure-Preferences} ist einfach und analog zur Verwendung der
Standard-\verb!SharedPreferences!. Das physikalische erstellen der Datei auf dem Datenträger geschieht durch das
Instanziieren der Klasse \texttt{SecurePreferences} im \verb!Context! der App. Wie auch bei den \verb!SharedPreferences!
kann auch hier optional ein eigener Name für die Datei übergeben werden, ist hier jedoch nicht notwendig. Hat sich ein
Benutzer angemeldet und wird die App geschlossen, wird die Funktion \textsl{storeCredentials(\ldots{})}
(Zeile \ref{line:secPrefsStore}) aufgerufen und die Referenz zum \emph{SecurePreferences}-Objekt sowie die
\texttt{AuthCredentials} übergeben. Damit überhaupt Daten geschrieben werden können, muss zunächst ein \texttt{Editor}-Objekt
erstellt werden, was durch \verb!.edit()! in Zeile \ref{line:secPrefsEdit} geschieht. Damit einen eventuell verwaister Eintrag
keine Probleme bereitet, wird der Speicher in der folgenden Zeile sicherheitshalber komplett gelöscht. Danach werden die
Attribute aus dem \texttt{AuthCredentials}-Objekt ausgelesen und zusammen mit einem eindeutigen Bezeichner durch den
\verb!.put(\ldots{})!-Befehl dem \verb!Editor! zum Speichern übergeben (vgl. Zeile \ref{line:secPrefsPut} ff). Um die
Daten nun physikalisch zu schreiben, wird auf dem \verb!Editor! \verb!.commit()! (vgl. Zeile
\ref{line:secPrefsCommit})
ausgeführt. Ausgelesen werden die Daten einfach in der umgekehrten Reihenfolge, mit dem einzigen Unterschied, dass
hierzu kein \verb!Editor! benötigt wird. Wird zum Beispiel die App gestartet, ruft die
\textsl{onResume()}-Methode die Methode \textsl{loggedInUser(\ldots{})} in Zeile \ref{line:secPrefsLogged} auf.
Darin wird nach dem Sicherstellen ob Zugangsdaten vorhanden sind, die einzelnen Schlüssel-Wert-Paare wieder ausgelesen
(siehe Zeile \ref{line:secPrefsGet} ff). Ist keiner der Werte \verb!null!, werden sie in einem \texttt{AuthCredentials}
verpackt zurückgegeben.

\begin{figure}[H]
  \centering
  
  \begin{lstlisting}[language=java,escapechar=|]
[|\ldots{}|]
public void resetCredentials(final SecurePreferences secPrefs) {
  Editor secPrefEditor = secPrefs.edit();
  secPrefEditor.clear();
  secPrefEditor.commit();
}
public static void storeCredentials(final SecurePreferences secPrefs,
  AuthCredentials _creds) { |\label{line:secPrefsStore}|
  Editor secPrefEditor = secPrefs.edit(); |\label{line:secPrefsEdit}|
  secPrefEditor.clear();
  secPrefEditor.putString(EnumSqLite.KEY_UID.getName(), 
      _creds.getUid()); |\label{line:secPrefsPut}|
  secPrefEditor.putString(EnumSqLite.KEY_PASSWORD.getName(),
      _creds.getPassword());
  secPrefEditor.putString(EnumSqLite.KEY_EMAIL.getName(), 
      _creds.getEmail());
  secPrefEditor.commit(); |\label{line:secPrefsCommit}|
}
public static AuthCredentials loggedInUser(final SecurePreferences secPrefs) { |\label{line:secPrefsLogged}|
  String uid = null, uname = null, upassword = null, email = null;
  if (!secPrefs.getAll().isEmpty()) {
    uid = secPrefs.getString(EnumSqLite.KEY_UID.getName(), null); |\label{line:secPrefsGet}|
    upassword = secPrefs.getString(EnumSqLite.KEY_PASSWORD.getName(), null);
    email = secPrefs.getString(EnumSqLite.KEY_EMAIL.getName(), null);
  }
  if (uid != null & upassword != null & email != null ) {
    AuthCredentials creds = new AuthCredentials(uid, email, upassword); |\label{line:secPrefsAuth}|
    return creds;
  }
  return null;
}
[|\ldots{}|]
  \end{lstlisting}
  \caption{Verwendung von Secure-Preferences}
  \label{java:UsingSecPrefs}
\end{figure}

Hat man schon mit den \verb!SharedPreferences! gearbeitet, kann man klar die analoge Vorgehenseweise erkennen.
Obwohl die Entwickler keine hunderprozentige Sicherheit garantieren können und möchten, ist es dennoch dem
unverschlüsselten Ablegen vorzuziehen.

\paragraph{Messenger-Klasse}\label{para:Messenger}
Wie schon erwähnt, sollte eine Trennung von Oberflächen- und Datenlogik erstrebt werden.
Um diese Trennung zu erreichen, wurde die \texttt{Messenger}-Klasse verwendet \cite{MessengerClass:14}. 
Mit dieser Klasse ist die Implementierung eines \verb!gebundenen Service! einfacher als eine mit einer
\verb!AIDL!-Schnittstelle, erfüllt aber alle Vorraussetzungen die für dieses Programm witchtig sind. 
\\*
Der Aufbau der \emph{Messenger}-Schnittstelle ist übersichtlich und mit wenigen Schritten erreicht. Zunächst wird eine
\texttt{MessengerService}-Klasse erstellt, die von der \texttt{Service}-Klasse erbt. Somit muss die Methode 
\textsl{onBind(\ldots{})} (vgl. Zeile \ref{line:MsgBinder}) implementiert werden, welche als \verb!Binder!
eine Instanz der inneren Klasse \texttt{IncomingHandler} zurückgibt (vgl. Zeile \ref{line:newMessngr}).
Der \texttt{IncomingHandler} arbeitet die eingehenden Anfragen 
seriell ab und führt mittels einer \verb!switch-case!-Anweisung die erwünschten
Operationen aus (wie in Zeile \ref{line:handleMsg} ff zu sehen).

\begin{figure}[H]
  \centering
  \begin{lstlisting}[language=java,escapechar=|]
[|\ldots{}|]
  private final Messenger mMessenger = new Messenger(new IncomingHandler()); |\label{line:newMessngr}|
[|\ldots{}|]
@Override
public IBinder onBind(Intent intent) { |\label{line:MsgBinder}|
  return mMessenger.getBinder();
}
public class IncomingHandler extends Handler {

  public static final String TAG = Constants.TAG_PREFIX + "IncomingHandler";

  @Override
  public void handleMessage(Message msg) { |\label{line:handleMsg}|
    // TODO
    String[] tablesToSync;
    int ppAufgId;
    Bundle _bundle;
    Map<String, String> params;
    int remItemId, shoppingListId;
    switch (msg.what) {
        case MessageConstants.MSG_UNREBIND:
            reService = null;
            reBound = false;
            break;
      {|\ldots{}|}
     }
     {|\ldots{}|}
   }
   {|\ldots{}|}
}
[|\ldots{}|]
  \end{lstlisting}
  \caption{Auszug aus MessengerService.java}
  \label{java:MessengerService}
\end{figure}

Neben den erwähnten Methoden enthält die Klasse \texttt{MessengerService} außerdem noch einige Hilfsmethoden, die zum
Beispiel zum Entpacken der \verb!Bundles! verwendet werden.
